Y <- 15 + 3*X + Z/2 + E
data = data.frame(X,Z,Y)
return(data)
}
res6 <- fonction6(200)
plot(res6$Y)
# 7.
nobs = 200
X <- runif(nobs, min=0, max=1)
Z <- data.frame(seq(1,nobs), X^2)
Z[,1]
fonction7 <- function(n) {
X <- runif(n, min=0, max=1)
Z <- data.frame(seq(1,n), X^2)
E <- rnorm(n, mean=0, sd=1)
Y <- 15 + 3*X + Z[,1]/10 + Z[,2]/2 + E
data = data.frame(X,Z,Y)
return(data)
}
res7 <- fonction7(200)
plot(res7$Y)
# lm : procedure de regression lineaire par moindres carres ordinaires
lm(res7$Y ~ res7[,2])
# Tracer sur le graph la droite de regression de Y en fonction de l index
abline(lm(res7$Y ~ res7[,2]), col = "red")
rm(list = ls())
setwd("P:/Ludo/Cours2A/UE2 Apprentissage supervise/TP/TP2")
# Important de considerer les str comme des factors car cela est important pour les algo de classification
mush <- read.csv(file = "muschroom.csv", stringsAsFactors = TRUE, sep=",")
summary(mush)
str(mush)
# Important de considerer les str comme des factors car cela est important pour les algo de classification
mush <- read.csv(file = "muschroom.csv", stringsAsFactors = TRUE, sep=",")
setwd("P:/Ludo/Cours2A/UE2 Apprentissage supervise/TP/TP2")
setwd("P:/Ludo/Cours2A/UE2 Apprentissage supervise/TP/TP2")
rm(list = ls())
setwd("P:/Ludo/Cours2A/UE2 Apprentissage supervise/TP/TP2")
rm(list=ls())
library(FactoMineR)
setwd("P:/Ludo/Tuto/R-tuto")
temperature <- read.table("data/temperatures.csv",
header = TRUE,
sep = ";",
row.names = 1)
# on transforme la variable Region est factor
temperature$Region <- as.factor(temperature$Region)
str(temperature)
summary(temperature)
# On voit que sur des mois proches les températures sont très corrélées
plot(temperature[,1:6])
plot(temperature[,7:12])
# On réalise une ACP avec
#   variables actives         : uniquement les températures mensuelles (colonnes 1 à 12)
#   individus actifs          : principalement les capitales (lignes 1 à 23)
#   individus supplémentaires : les autres villes (lignes 24 à 35)
# Les individus supplémentaires ne participent pas à la création des axes
# mais l'on souhaite tout de même les observer sur les nouveaux axes
res_acp <- PCA(temperature[,1:12], ind.sup = c(24:35), graph = FALSE)
summary(res_acp)
View(res_acp)
res_acp$eig
# Inertie par axe
barplot(res_acp$eig[,1], main="Valeurs propres", names.arg = paste0("dim", 1:nrow(res_acp$eig)))
# Inertie par axe
barplot(res_acp$eig[,2], names.arg = paste0("dim", 1:nrow(res_acp$eig)),
main="Valeurs propres")
# Inertie par axe
barplot(res_acp$eig[,2], names.arg = paste0("dim", 1:nrow(res_acp$eig)),
main="Inertie par axe")
# Inertie par axe
barplot(res_acp$eig[,2], names.arg = paste0("dim", 1:nrow(res_acp$eig)),
ylim = c(0,100),
main="Inertie par axe")
# Cercle des corrélations
#   toutes les fléches vont dans la même direction : c'est un effet taille
plot(res_acp, choix = "var")
# Nuage des individus selon les deux premiers axes factoriels
plot(res_acp, choix = "ind")
# Individus les mieux représentés sur l'axe 1
#   ie ceux qui ont un cos2 proche de 1
res_acp$var$cos2[order(res_acp$var$cos2[,"Dim.1"], decreasing=TRUE),]
# Individus les plus contributeurs à la construction de l'axe 2
res_acp$var$contrib[order(res_acp$var$contrib[,"Dim.2"], decreasing=TRUE),]
res_acp$var$cos2
res_acp$
# Individus les mieux représentés sur l'axe 1
#   ie ceux qui ont un cos2 proche de 1
res_acp$var$cos2[order(res_acp$var$cos2[,"Dim.1"], decreasing=TRUE),]
res_acp$ind
# Individus les mieux représentés sur l'axe 1
#   ie ceux qui ont un cos2 proche de 1
res_acp$ind$cos2[order(res_acp$ind$cos2[,"Dim.1"], decreasing=TRUE),]
# Individus les plus contributeurs à la construction de l'axe 2
res_acp$ind$contrib[order(res_acp$ind$contrib[,"Dim.2"], decreasing=TRUE),]
# ACP en ajoutant des variables supplémentaires
res_acp2 <- PCA(temperature, ind.sup = c(24:35),
quali.sup=17, quanti.sup=c(13:16), graph = FALSE)
# Mise en évidence des régions
plot(res_acp2, choix = "ind",
habillage = "Region",
col.hab = c("grey", "blue", "black", "orange"))
# Mise en évidence des régions
plot(res_acp2, choix = "ind",
habillage = "Region",
col.hab = c("grey", "blue", "black", "red"))
temperature
temperature$Amplitude
c(rownames(temperature),temperature$Amplitude)
cbind(rownames(temperature),temperature$Amplitude)
str(temp)
str(temperature)
dataToCluster <- temperature[, 1:12]
View(dataToCluster)
# On ne garde que les variables de temprératures mensuelles
dataToCluster <- temperature[, 1:12]
# Suppression des variables non numériques
dataToCluster <- Filter(is.numeric, temperature)
# Centrage des variables
dataToCluster <- scale(dataToCluster)
dataToCluster
# On ne garde que les variables de temprératures mensuelles
dataToCluster <- temperature[, 1:12]
# Suppression des variables non numériques
dataToCluster <- Filter(is.numeric, dataToCluster)
# Centrage des variables
dataToCluster <- scale(dataToCluster)
dataToCluster
head(dataToCluster)
# initialisation de variables utiles
nb_cluster_max = 8
resKmeans <- list() # va contenir les resultats des k-means pour chaque valeur de K
CPtheta <- rep(0,nb_cluster_max) # va contenir l'inertie intra pour chaque valeur de K
# Pour K allant de 1 a 8 (nombre de clusters)
for (K in 1:nb_cluster_max){
resKmeans[[K]] <- kmeans(dataToCluster, K, nstart = 50)
CPtheta[K] <- resKmeans[[K]]$tot.withinss
}
# on voit que le coude qu en dessous de 3 clusters l inertie intra augmente significativement (coude)
plot(x= 1:nb_cluster_max,
y= CPtheta,
type = "b",
xlab = "K",
ylab = "Inertie intra",
main = "Inertie intra-cluster en fonction du nombre de clusters")
# Nombre d'éléments dans chacun des 3 clusters
resKmeans[[3]]$size
# Ajout de la variable qualitative cluster
cluster_kmeans <- resKmeans[[3]]$cluster
temperature <- cbind(temperature, cluster_kmeans)
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(temperature,
quali.sup = which(colnames(temperature) == 'cluster_kmeans'))
dataToCluster <- cbind(temperature, cluster_kmeans)
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(dataToCluster,
quali.sup = which(colnames(dataToCluster) == 'cluster_kmeans'))
temperature <- read.table("data/temperatures.csv",
header = TRUE,
sep = ";",
row.names = 1)
# on transforme la variable Region est factor
temperature$Region <- as.factor(temperature$Region)
str(temperature)
# On ne garde que les variables de temprératures mensuelles
dataToCluster <- temperature[, 1:12]
# Suppression des variables non numériques
dataToCluster <- Filter(is.numeric, dataToCluster)
# Centrage des variables
dataToCluster <- scale(dataToCluster)
head(dataToCluster)
# -------------------------------------------------
# Algo du K-means
# -------------------------------------------------
nb_cluster_max <- 8
resKmeans <- list()              # va contenir les resultats des k-means pour chaque valeur de K
CPtheta <- rep(0,nb_cluster_max) # va contenir l'inertie intra pour chaque valeur de K
# Pour K allant de 1 a 8 (nombre de clusters)
for (K in 1:nb_cluster_max){
resKmeans[[K]] <- kmeans(dataToCluster, K, nstart = 50)
CPtheta[K] <- resKmeans[[K]]$tot.withinss
}
# on voit qu en dessous de 3 clusters l'inertie intra augmente significativement (coude)
plot(x= 1:nb_cluster_max,
y= CPtheta,
type = "b",
xlab = "K",
ylab = "Inertie intra",
main = "Inertie intra en fonction du nombre de clusters")
# Nombre d'éléments dans chacun des 3 clusters
resKmeans[[3]]$size
# Ajout de la variable qualitative cluster
cluster_kmeans <- resKmeans[[3]]$cluster
dataToCluster <- cbind(dataToCluster, cluster_kmeans)
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(dataToCluster,
quali.sup = which(colnames(dataToCluster) == 'cluster_kmeans'))
plot.PCA(acp_kmeans,
choix = "ind",
habillage = "cluster_kmeans",
col.hab=c("blue","red","green"),
invisible = c("quali"),
title = "Clustering par K-means")
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(dataToCluster,
quali.sup = which(colnames(dataToCluster) == 'cluster_kmeans'),
graph = FALSE)
plot.PCA(acp_kmeans,
choix = "ind",
habillage = "cluster_kmeans",
col.hab=c("blue","red","green"),
invisible = c("quali"),
title = "Clustering par K-means")
dataToCluster
str(dataToCluster)
dataToCluster
dataToCluster$cluster_kmeans
dataToCluster$cluster_kmeans
dataToCluster$
#######################################################
# --------------------------------------------------------------------
# True ACP
# --------------------------------------------------------------------
# Variables quantitatives supplémtentaires
var_quanti_sup <- c('Part.retraités.2013', 'Taux.évolution.solde.migratoire.2013.2018',
'Part.propriétaires.65plus.2018','Taux.emploi.55.64.2018','Taux.pauvreté.2018',
'Population.2018','Taux évolution population 2013-2018')
temperature <- read.table("data/temperatures.csv",
header = TRUE,
sep = ";",
row.names = 1)
# on transforme la variable Region est factor
temperature$Region <- as.factor(temperature$Region)
str(temperature)
# On ne garde que les variables de températures mensuelles
temperature <- temperature[, 1:12]
# Suppression des variables non numériques
dataToCluster <- Filter(is.numeric, dataToCluster)
# Centrage des variables
dataToCluster <- scale(dataToCluster)
head(dataToCluster)
# -------------------------------------------------
# Algo du K-means
# -------------------------------------------------
nb_cluster_max <- 8
resKmeans <- list()              # va contenir les resultats des k-means pour chaque valeur de K
CPtheta <- rep(0,nb_cluster_max) # va contenir l'inertie intra pour chaque valeur de K
# Pour K allant de 1 a 8 (nombre de clusters)
for (K in 1:nb_cluster_max){
resKmeans[[K]] <- kmeans(dataToCluster, K, nstart = 50)
CPtheta[K] <- resKmeans[[K]]$tot.withinss
}
# on voit qu en dessous de 3 clusters l'inertie intra augmente significativement (coude)
plot(x= 1:nb_cluster_max,
y= CPtheta,
type = "b",
xlab = "K",
ylab = "Inertie intra",
main = "Inertie intra en fonction du nombre de clusters")
# Nombre d'éléments dans chacun des 3 clusters
resKmeans[[3]]$size
# Ajout de la variable qualitative cluster
cluster_kmeans <- resKmeans[[3]]$cluster
temperature <- cbind(dataToCluster, cluster_kmeans)
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(temperature,
quali.sup = which(colnames(temperature) == 'cluster_kmeans'),
graph = FALSE)
plot.PCA(acp_kmeans,
choix = "ind",
habillage = "cluster_kmeans",
col.hab = c("blue","red","green"),
invisible = c("quali"),
title = "Clustering par K-means")
temperature <- read.table("data/temperatures.csv",
header = TRUE,
sep = ";",
row.names = 1)
# on transforme la variable Region est factor
temperature$Region <- as.factor(temperature$Region)
str(temperature)
# On ne garde que les variables de températures mensuelles
temperature <- temperature[, 1:12]
# Suppression des variables non numériques
dataToCluster <- Filter(is.numeric, dataToCluster)
# Centrage des variables
dataToCluster <- scale(dataToCluster)
# Suppression des variables non numériques
dataToCluster <- Filter(is.numeric, temperature)
# Centrage des variables
dataToCluster <- scale(dataToCluster)
head(dataToCluster)
nb_cluster_max <- 8
resKmeans <- list()              # va contenir les resultats des k-means pour chaque valeur de K
CPtheta <- rep(0,nb_cluster_max) # va contenir l'inertie intra pour chaque valeur de K
# Pour K allant de 1 a 8 (nombre de clusters)
for (K in 1:nb_cluster_max){
resKmeans[[K]] <- kmeans(dataToCluster, K, nstart = 50)
CPtheta[K] <- resKmeans[[K]]$tot.withinss
}
# on voit qu en dessous de 3 clusters l'inertie intra augmente significativement (coude)
plot(x= 1:nb_cluster_max,
y= CPtheta,
type = "b",
xlab = "K",
ylab = "Inertie intra",
main = "Inertie intra en fonction du nombre de clusters")
# Nombre d'éléments dans chacun des 3 clusters
resKmeans[[3]]$size
# Ajout de la variable qualitative cluster
cluster_kmeans <- resKmeans[[3]]$cluster
temperature <- cbind(dataToCluster, cluster_kmeans)
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(temperature,
quali.sup = which(colnames(temperature) == 'cluster_kmeans'),
graph = FALSE)
plot.PCA(acp_kmeans,
choix = "ind",
habillage = "cluster_kmeans",
col.hab = c("blue","red","green"),
invisible = c("quali"),
title = "Clustering par K-means")
str(temperature)
View(temperature)
temperature <- cbind(temperature, cluster_kmeans)
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(temperature,
quali.sup = which(colnames(temperature) == 'cluster_kmeans'),
graph = FALSE)
plot.PCA(acp_kmeans,
choix = "ind",
habillage = "cluster_kmeans",
col.hab = c("blue","red","green"),
invisible = c("quali"),
title = "Clustering par K-means")
str(temperature)
temperature$cluster_kmeans
rm(list=ls())
setwd("P:/Ludo/Tuto/R-tuto")
temperature <- read.table("data/temperatures.csv",
header = TRUE,
sep = ";",
row.names = 1)
# on transforme la variable Region est factor
temperature$Region <- as.factor(temperature$Region)
library(FactoMineR)
# on transforme la variable Region est factor
temperature$Region <- as.factor(temperature$Region)
str(temperature)
# On ne garde que les variables de températures mensuelles
temperature <- temperature[, 1:12]
# Suppression des variables non numériques
dataToCluster <- Filter(is.numeric, temperature)
# Centrage des variables
dataToCluster <- scale(dataToCluster)
head(dataToCluster)
nb_cluster_max <- 8
resKmeans <- list()              # va contenir les resultats des k-means pour chaque valeur de K
CPtheta <- rep(0,nb_cluster_max) # va contenir l'inertie intra pour chaque valeur de K
# Pour K allant de 1 a 8 (nombre de clusters)
for (K in 1:nb_cluster_max){
resKmeans[[K]] <- kmeans(dataToCluster, K, nstart = 50)
CPtheta[K] <- resKmeans[[K]]$tot.withinss
}
# on voit qu en dessous de 3 clusters l'inertie intra augmente significativement (coude)
plot(x= 1:nb_cluster_max,
y= CPtheta,
type = "b",
xlab = "K",
ylab = "Inertie intra",
main = "Inertie intra en fonction du nombre de clusters")
# Nombre d'éléments dans chacun des 3 clusters
resKmeans[[3]]$size
# Ajout de la variable qualitative cluster
cluster_kmeans <- resKmeans[[3]]$cluster
temperature <- cbind(temperature, cluster_kmeans)
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(temperature,
quali.sup = which(colnames(temperature) == 'cluster_kmeans'),
graph = FALSE)
plot.PCA(acp_kmeans,
choix = "ind",
habillage = "cluster_kmeans",
col.hab = c("blue","red","green"),
invisible = c("quali"),
title = "Clustering par K-means")
str(temperature)
temperature$cluster_kmeans <- as.factor(temperature$cluster_kmeans)
plot.PCA(acp_kmeans,
choix = "ind",
habillage = "cluster_kmeans",
col.hab = c("blue","red","green"),
invisible = c("quali"),
title = "Clustering par K-means")
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(temperature,
quali.sup = which(colnames(temperature) == 'cluster_kmeans'),
graph = FALSE)
plot.PCA(acp_kmeans,
choix = "ind",
habillage = "cluster_kmeans",
col.hab = c("blue","red","green"),
invisible = c("quali"),
title = "Clustering par K-means")
temperature <- cbind(temperature, as.factor(cluster_kmeans))
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(temperature,
quali.sup = which(colnames(temperature) == 'cluster_kmeans'),
graph = FALSE)
rm(list=ls())
setwd("P:/Ludo/Tuto/R-tuto")
temperature <- read.table("data/temperatures.csv",
header = TRUE,
sep = ";",
row.names = 1)
# on transforme la variable Region est factor
temperature$Region <- as.factor(temperature$Region)
str(temperature)
# On ne garde que les variables de températures mensuelles
temperature <- temperature[, 1:12]
# Suppression des variables non numériques
dataToCluster <- Filter(is.numeric, temperature)
# Centrage des variables
dataToCluster <- scale(dataToCluster)
head(dataToCluster)
nb_cluster_max <- 8
resKmeans <- list()              # va contenir les resultats des k-means pour chaque valeur de K
CPtheta <- rep(0,nb_cluster_max) # va contenir l'inertie intra pour chaque valeur de K
# Pour K allant de 1 a 8 (nombre de clusters)
for (K in 1:nb_cluster_max){
resKmeans[[K]] <- kmeans(dataToCluster, K, nstart = 50)
CPtheta[K] <- resKmeans[[K]]$tot.withinss
}
# on voit qu en dessous de 3 clusters l'inertie intra augmente significativement (coude)
plot(x= 1:nb_cluster_max,
y= CPtheta,
type = "b",
xlab = "K",
ylab = "Inertie intra",
main = "Inertie intra en fonction du nombre de clusters")
# Nombre d'éléments dans chacun des 3 clusters
resKmeans[[3]]$size
# Ajout de la variable qualitative cluster
cluster_kmeans <- resKmeans[[3]]$cluster
temperature <- cbind(temperature, as.factor(cluster_kmeans))
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(temperature,
quali.sup = which(colnames(temperature) == 'cluster_kmeans'),
graph = FALSE)
temperature
temperature <- cbind(temperature, cluster_kmeans = as.factor(cluster_kmeans))
temperature
# On ne garde que les variables de températures mensuelles
temperature <- temperature[, 1:12]
temperature <- cbind(temperature, cluster_kmeans = as.factor(cluster_kmeans))
temperature
# Visulisation des 3 clusters sur une ACP
acp_kmeans <- PCA(temperature,
quali.sup = which(colnames(temperature) == 'cluster_kmeans'),
graph = FALSE)
plot.PCA(acp_kmeans,
choix = "ind",
habillage = "cluster_kmeans",
col.hab = c("blue","red","green"),
invisible = c("quali"),
title = "Clustering par K-means")
# CAH avec critere de Ward
#    method = "single" pour mini
CAHward <- agnes(dataToCluster, metric = "euclidean", method = "ward")
library(cluster)
# CAH avec critere de Ward
#    method = "single" pour mini
CAHward <- agnes(dataToCluster, metric = "euclidean", method = "ward")
plot(CAHward,
which.plots = 2,
main = "Dendogramme Ward")
# Ajout de la variable qualitative cluster
cluster_cah <- cutree(CAHward, 3)
matrice <- cbind(matrice, cluster_cah)
temperature <- cbind(temperature, cluster_cah = as.factor(cluster_cah))
# Visulisation des 3 clusters sur une ACP
acp_cah <- PCA(matrice,
quali.sup = which(colnames(matrice) == 'cluster_cah'),
graph = FALSE)
# Visulisation des 3 clusters sur une ACP
acp_cah <- PCA(temperature,
quali.sup = which(colnames(matrice) == 'cluster_cah'),
graph = FALSE)
# Visulisation des 3 clusters sur une ACP
acp_cah <- PCA(temperature,
quali.sup = which(colnames(temperature) == 'cluster_cah'),
graph = FALSE)
temperature
# Visulisation des 3 clusters sur une ACP
acp_cah <- PCA(temperature,
quali.sup = which(colnames(temperature) in c("cluster_cah","cluster_kmeans")),
graph = FALSE)
# Visulisation des 3 clusters sur une ACP
acp_cah <- PCA(temperature,
quali.sup = which(colnames(temperature) %in% c("cluster_cah","cluster_kmeans")),
graph = FALSE)
plot.PCA(acp_cah,
choix = "ind",
habillage = "cluster_cah",
invisible = c("quali"),
title = "Clustering par CAH")
partitionCAH <- cutree(CAHward, 3)
partitionKmeans <- kmeans(dataToCluster, 3)
# Matrice de confusion entre les deux partitions
table(partitionKmeans$cluster, partitionCAH)
# Adjusted Rand Index (Indice de Rand)
ARI(partitionKmeans$cluster, partitionCAH)
library(VarSelLCM)
